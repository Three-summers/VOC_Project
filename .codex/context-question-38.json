{
  "timestamp": "2025-12-11T03:10:58Z",
  "question": "现有数据模型/渲染链能否支撑“高速刷新”频谱所需的吞吐与分辨率？",
  "why": "频谱图通常需要高频率（几十毫秒甚至更短）批量更新，且渲染为二维纹理；当前实现基于折线模型，可能在数据量和刷新率上存在瓶颈。",
  "findings": {
    "模型裁剪": "SeriesTableModel 默认 max_rows=60（app.py 创建时显式传入 60），append_point 逐条插入并在溢出时 beginRemoveRows -> pop(0)；高频场景将频繁触发移除/重算边界。",
    "信号频率": "FoupAcquisitionController 每收到一条消息就发 dataPointReceived(x, values)，随后 _append_point_to_model 对每个通道调用 model.append_point；无批处理或降采样，QAbstractTableModel 信号会在高频下造成 UI 线程压力。",
    "渲染路径": "ChartCard 使用 QtCharts.ChartView + LineSeries/ScatterSeries + VXYModelMapper；每次 boundsChanged 触发 updateAxesFromSeries -> updateLimitLines（重建多条参考线）；useOpenGL 已注释，实际为 CPU 绘制，且限值线每次重绘 O(N)。",
    "UI 布局": "StatusView 中对 FOUP 通道使用 GridLayout + ChartCard，每个卡片都独立更新；多通道并行时 UI 线程负载线性增长。",
    "示例刷新率": "app.py 的示例定时器 1s 生成一次点，仅验证低频场景；无现成路径展示>10Hz以上的刷新。"
  }
}

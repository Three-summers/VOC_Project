{
  "timestamp": "2025-11-19T16:02:10+08:00",
  "moduleLocations": {
    "e84_core": "new_loadport/E84Passive.py 负责 E84 状态机与 GPIO 控制",
    "thread_wrapper": "new_loadport/e84_thread.py 将 E84Controller 放入 QThread",
    "gpio_driver": "new_loadport/GPIOController.py 用于读写引脚状态",
    "serial_stack": "(已删除) CMDSerial/DeviceController/SerialManager 旧串口栈，当前不存在通用串口实现"
  },
  "currentImplementation": {
    "serial_dependency": "项目当前没有任何串口封装，E84 控制器完全依赖 GPIO 与 PySide6 定时器",
    "thread_entry": "new_loadport/main.py 启动 QCoreApplication 并运行 E84ControllerThread",
    "gui": "gui_main 目录提供 QML UI，与 new_loadport 通过桥接类通信"
  },
  "similarReferences": {
    "old_serial": "Git 历史中曾有 SerialManager/CMDSerial，可参考其接口风格重建新通用串口组件"
  },
  "techStack": [
    "Python 3",
    "PySide6 (QtCore/QThread)",
    "期望新的串口模块基于 pyserial 或可插拔串口工厂"
  ],
  "testsAndVerification": {
    "automated": [],
    "notes": "运行 new_loadport/main.py 仍受制于 PySide6 依赖；串口模块需提供可模拟接口便于测试"
  },
  "observationReport": {
    "gaps": [
      "缺少可配置的串口通讯层，无法按命令表配置不同设备",
      "现有代码没有抽象的命令解析与接收逻辑"
    ],
    "suggestedNext": [
      "设计一个 GenericSerialDevice 类，构造时注入命令表与解析器",
      "为发送/接收提供钩子或回调，以便定制",
      "考虑线程安全和异步事件（可复用之前的 reader 线程模式）"
    ],
    "toolingNotes": "无 code-index 工具，只能使用 rg/sed"
  }
}

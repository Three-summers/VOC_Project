# 明白了！FOUP 往返采集数据的方案

## 一、场景理解

```
完整流程：

1. FOUP 在 LoadPort 上（有网线连接）
   ↓
2. LoadPort 发送 START 命令 ← 【关键点1】
   ↓
3. 天车抓走 FOUP（网线断开）
   ↓
4. FOUP 在天上自主采集数据（无网络连接）
   ↓
5. 天车将 FOUP 送到其他设备加工
   ↓
6. 加工完成，天车抓起 FOUP
   ↓
7. FOUP 继续在天上采集数据
   ↓
8. 天车将 FOUP 送回原 LoadPort（网线重新连接）
   ↓
9. LoadPort 发送 STOP 命令 ← 【关键点2】
   ↓
10. LoadPort 读取 FOUP 采集的数据
```

---

## 二、推荐方案：基于 E84 Unload/Load 时序

### **完整时序图：**

```
═══════════════════════════════════════════════════════════════════════
阶段1：FOUP 卸载（Unload）- 发送 START 命令
═══════════════════════════════════════════════════════════════════════

LoadPort 信号：
U_REQ:    ────┐                                        
READY:    ────└──┐                                     
CS_0:     ───┐   └──────────────────────────────┐     
              ↑                                  ↓     
            FOUP在                            FOUP被抓走

AMHS 信号：
VALID:    ────────└──┐                     ┌────       
TR_REQ:   ──────────────└──┐           ┌───            
BUSY:     ──────────────────└──┐   ┌───                
COMPT:    ───────────────────────└──┐                  

你的命令：
          ┌─ 发送 START 命令
          ↓
时机：U_REQ=1 且 READY=1 之后，BUSY=1 之前
原因：此时网线还连接，FOUP 即将被抓走


═══════════════════════════════════════════════════════════════════════
阶段2：FOUP 在天上（离线采集）
═══════════════════════════════════════════════════════════════════════

[FOUP 自主运行，采集传感器数据]
- 加速度、振动、温度等
- 数据存储在 FOUP 内部存储器
- 无网络连接


═══════════════════════════════════════════════════════════════════════
阶段3：FOUP 装载回来（Load）- 发送 STOP 命令
═══════════════════════════════════════════════════════════════════════

LoadPort 信号：
L_REQ:    ────┐                                        
READY:    ────└──┐                                     
CS_0:     ───────────┐                              ┌────
                    ↑                              ↓   
                 FOUP回来                      网线重连 

AMHS 信号：
VALID:    ────────────└──┐                     ┌────   
TR_REQ:   ─────────────────└──┐           ┌────        
BUSY:     ──────────────────────└──┐  ┌───             
COMPT:    ───────────────────────────└──┐              
                                        ↑
                                   发送 STOP 命令
                                      
时机：COMPT=1 之后，信号复位之前
原因：网线已重连，FOUP 已稳定放置，可以通信
```

---

## 三、最佳触发时机

### ✅ **START 命令：Unload 时，VALID=1 之后立即发送**

```
时序：
U_REQ=1 → READY=1 → VALID=1 → 【发送START】 → TR_REQ=1 → BUSY=1
                              ↑
                         在这里发送
```

**原因：**
1. ✅ FOUP 还在 LoadPort 上，网线连接正常
2. ✅ AMHS 已确认到位（VALID=1），即将开始抓取
3. ✅ 距离 BUSY（开始抓取）还有 2-3 秒，足够发送命令
4. ✅ 如果发送失败，还可以中止传输

**风险分析：**
- ❌ 如果在 BUSY=1 之后发送：网线可能已经被拉扯，通信不稳定
- ❌ 如果在 U_REQ=1 时发送：太早，AMHS 可能还没准备好，传输可能取消

---

### ✅ **STOP 命令：Load 时，COMPT=1 之后立即发送**

```
时序：
CS_0=1 → VALID=1 → TR_REQ=1 → BUSY=0 → COMPT=1 → 【发送STOP】
                                                  ↑
                                             在这里发送
```

**原因：**
1. ✅ FOUP 已完全放置到 LoadPort
2. ✅ 网线已重新连接且稳定
3. ✅ AMHS 已完成传输（COMPT=1），不会再移动 FOUP
4. ✅ 可以立即读取数据

**风险分析：**
- ❌ 如果在 CS_0=1 时发送：网线可能刚接触，连接不稳定
- ❌ 如果在 BUSY=1 时发送：FOUP 还在移动，网线可能未连接

---

## 四、完整代码实现

```python
class LoadPortWithFOUPDataCollection:
    def __init__(self):
        self.foup_session_id = None
        self.data_collection_started = False
      
    # ═══════════════════════════════════════════════════════
    # 阶段1：卸载 FOUP 并启动数据采集
    # ═══════════════════════════════════════════════════════
  
    def unload_carrier_with_data_start(self):
        """卸载载具并发送开始采集命令"""
        try:
            # 步骤1：发起卸载请求
            self.set_signal('U_REQ', HIGH)
            self.log("Unload request initiated")
          
            # 步骤2：准备就绪
            if not self.prepare_for_unload(timeout=2):
                raise TimeoutError("Unload preparation timeout")
          
            self.set_signal('READY', HIGH)
            self.log("Ready for unload")
          
            # 步骤3：等待 AMHS 到达并确认
            if not self.wait_for_signal('VALID', HIGH, timeout=30):
                raise TimeoutError("AMHS arrival timeout")
          
            self.log("AMHS arrived and confirmed position")
          
            # ✅ 关键点1：发送 START 命令
            # 此时网线还连接，FOUP 即将被抓走
            self.send_start_command_to_foup()
          
            # 步骤4：等待 TR_REQ
            if not self.wait_for_signal('TR_REQ', HIGH, timeout=3):
                raise TimeoutError("TR_REQ timeout")
          
            # 步骤5：等待 BUSY 完成（AMHS 抓取过程）
            if not self.wait_for_signal('BUSY', LOW, timeout=30):
                raise TimeoutError("AMHS pickup timeout")
          
            self.log("AMHS has picked up the FOUP")
          
            # 步骤6：等待 COMPT
            if not self.wait_for_signal('COMPT', HIGH, timeout=5):
                raise TimeoutError("Complete signal timeout")
          
            self.log("Unload complete - FOUP is now in transit")
          
            # 步骤7：复位信号
            self.reset_signals()
          
            return True
          
        except Exception as e:
            self.log(f"Error during unload: {e}")
            self.abort_transfer()
            return False
  
    def send_start_command_to_foup(self):
        """发送开始采集命令给 FOUP"""
        try:
            # 生成唯一会话ID
            self.foup_session_id = self.generate_session_id()
          
            # 通过网线发送命令
            command = {
                'action': 'START_DATA_COLLECTION',
                'session_id': self.foup_session_id,
                'timestamp': time.time(),
                'parameters': {
                    'sampling_rate': 100,  # Hz
                    'sensors': [
                        'accelerometer_x',
                        'accelerometer_y', 
                        'accelerometer_z',
                        'gyroscope_x',
                        'gyroscope_y',
                        'gyroscope_z',
                        'temperature',
                        'humidity'
                    ],
                    'storage_mode': 'circular_buffer',  # 循环缓冲
                    'max_duration': 3600,  # 最大1小时
                    'trigger_events': [
                        'high_vibration',  # 高振动事件
                        'sudden_acceleration',  # 突然加速
                        'temperature_spike'  # 温度突变
                    ]
                }
            }
          
            # 发送命令（带重试）
            success = self.send_command_with_retry(command, max_retries=3)
          
            if success:
                self.data_collection_started = True
                self.log(f"✓ START command sent successfully (Session: {self.foup_session_id})")
              
                # 保存到数据库
                self.db.insert({
                    'session_id': self.foup_session_id,
                    'foup_id': self.get_foup_id(),
                    'start_time': time.time(),
                    'status': 'collecting'
                })
            else:
                self.log("✗ Failed to send START command")
                raise Exception("START command failed")
              
        except Exception as e:
            self.log(f"Error sending START command: {e}")
            raise
  
    def send_command_with_retry(self, command, max_retries=3):
        """带重试的命令发送"""
        for attempt in range(max_retries):
            try:
                # 发送命令
                self.foup_comm.send(command)
              
                # 等待确认（ACK）
                ack = self.foup_comm.wait_for_ack(timeout=1.0)
              
                if ack and ack.get('status') == 'ok':
                    self.log(f"Command acknowledged on attempt {attempt + 1}")
                    return True
                  
            except Exception as e:
                self.log(f"Attempt {attempt + 1} failed: {e}")
                time.sleep(0.2)  # 短暂延迟后重试
      
        return False
  
    # ═══════════════════════════════════════════════════════
    # 阶段2：FOUP 返回并停止数据采集
    # ═══════════════════════════════════════════════════════
  
    def load_carrier_with_data_stop(self):
        """装载载具并发送停止采集命令"""
        try:
            # 步骤1：请求装载
            self.set_signal('L_REQ', HIGH)
            self.log("Load request initiated")
          
            # 步骤2：准备端口
            if not self.prepare_port(timeout=2):
                raise TimeoutError("Port preparation timeout")
          
            self.set_signal('READY', HIGH)
            self.log("Ready for load")
          
            # 步骤3：等待载具到达
            if not self.wait_for_signal('CS_0', HIGH, timeout=30):
                raise TimeoutError("Carrier arrival timeout")
          
            self.log("FOUP detected at port")
          
            # 步骤4：等待 VALID
            if not self.wait_for_signal('VALID', HIGH, timeout=5):
                raise TimeoutError("VALID signal timeout")
          
            # 步骤5：等待 TR_REQ
            if not self.wait_for_signal('TR_REQ', HIGH, timeout=3):
                raise TimeoutError("TR_REQ timeout")
          
            # 步骤6：等待传输完成
            if not self.wait_for_signal('BUSY', LOW, timeout=30):
                raise TimeoutError("Transfer timeout")
          
            # 步骤7：等待 COMPT
            if not self.wait_for_signal('COMPT', HIGH, timeout=5):
                raise TimeoutError("Complete signal timeout")
          
            self.log("FOUP placed successfully")
          
            # ✅ 关键点2：发送 STOP 命令
            # 此时网线已重新连接，FOUP 已稳定
            time.sleep(0.5)  # 等待网线连接稳定
            self.send_stop_command_to_foup()
          
            # 步骤8：读取数据
            foup_data = self.retrieve_foup_data()
          
            # 步骤9：处理数据
            self.process_and_save_data(foup_data)
          
            # 步骤10：锁定载具
            self.lock_carrier()
            self.reset_signals()
          
            return True
          
        except Exception as e:
            self.log(f"Error during load: {e}")
            self.abort_transfer()
            return False
  
    def send_stop_command_to_foup(self):
        """发送停止采集命令给 FOUP"""
        try:
            command = {
                'action': 'STOP_DATA_COLLECTION',
                'session_id': self.foup_session_id,
                'timestamp': time.time()
            }
          
            # 发送命令
            success = self.send_command_with_retry(command, max_retries=3)
          
            if success:
                self.data_collection_started = False
                self.log(f"✓ STOP command sent successfully (Session: {self.foup_session_id})")
              
                # 更新数据库
                self.db.update({
                    'session_id': self.foup_session_id,
                    'end_time': time.time(),
                    'status': 'completed'
                })
            else:
                self.log("✗ Failed to send STOP command")
                # 不抛出异常，尝试读取数据
              
        except Exception as e:
            self.log(f"Error sending STOP command: {e}")
            # 继续执行，尝试读取数据
  
    def retrieve_foup_data(self):
        """从 FOUP 读取采集的数据"""
        self.log("Retrieving data from FOUP...")
      
        try:
            # 请求数据传输
            request = {
                'action': 'GET_DATA',
                'session_id': self.foup_session_id,
                'format': 'compressed'  # 压缩格式
            }
          
            self.foup_comm.send(request)
          
            # 等待 FOUP 准备数据
            self.log("Waiting for FOUP to prepare data...")
            time.sleep(2)
          
            # 接收数据（可能很大，需要分块接收）
            data = self.receive_large_data(timeout=30)
          
            if data:
                self.log(f"✓ Received {len(data)} bytes from FOUP")
                return data
            else:
                self.log("✗ No data received from FOUP")
                return None
              
        except Exception as e:
            self.log(f"Error retrieving data: {e}")
            return None
  
    def receive_large_data(self, timeout=30):
        """接收大数据（分块接收）"""
        chunks = []
        start_time = time.time()
      
        while time.time() - start_time < timeout:
            try:
                chunk = self.foup_comm.receive(timeout=5)
              
                if chunk:
                    chunks.append(chunk)
                  
                    # 检查是否接收完成
                    if chunk.get('is_last_chunk'):
                        break
                else:
                    break
                  
            except Exception as e:
                self.log(f"Error receiving chunk: {e}")
                break
      
        if chunks:
            # 合并所有数据块
            return self.merge_chunks(chunks)
        else:
            return None
  
    def process_and_save_data(self, data):
        """处理并保存 FOUP 数据"""
        if not data:
            self.log("No data to process")
            return
      
        try:
            # 解析数据
            parsed_data = self.parse_foup_data(data)
          
            # 数据分析
            analysis = {
                'session_id': self.foup_session_id,
                'foup_id': self.get_foup_id(),
                'duration': parsed_data['duration'],
                'sample_count': parsed_data['sample_count'],
              
                # 振动分析
                'max_acceleration': max(parsed_data['accelerometer']),
                'avg_acceleration': np.mean(parsed_data['accelerometer']),
                'vibration_events': self.detect_vibration_events(parsed_data),
              
                # 温度分析
                'max_temperature': max(parsed_data['temperature']),
                'min_temperature': min(parsed_data['temperature']),
                'temp_variation': np.std(parsed_data['temperature']),
              
                # 异常事件
                'anomalies': self.detect_anomalies(parsed_data),
              
                # 质量评分
                'quality_score': self.calculate_quality_score(parsed_data)
            }
          
            # 保存到数据库
            self.db.save_analysis(analysis)
          
            # 保存原始数据（可选）
            if self.config.get('save_raw_data'):
                self.save_raw_data(parsed_data)
          
            self.log(f"✓ Data processed and saved (Quality: {analysis['quality_score']}/100)")
          
            # 如果质量评分低，发出警告
            if analysis['quality_score'] < 70:
                self.alarm(f"Low transport quality detected: {analysis['quality_score']}")
          
        except Exception as e:
            self.log(f"Error processing data: {e}")
  
    # ═══════════════════════════════════════════════════════
    # 辅助方法
    # ═══════════════════════════════════════════════════════
  
    def generate_session_id(self):
        """生成唯一会话ID"""
        import uuid
        return f"SESSION_{uuid.uuid4().hex[:8]}_{int(time.time())}"
  
    def get_foup_id(self):
        """读取 FOUP ID（通过 RFID）"""
        try:
            return self.rfid_reader.read_id()
        except:
            return "UNKNOWN"
  
    def detect_vibration_events(self, data):
        """检测振动事件"""
        events = []
        threshold = 2.0  # g
      
        for i, acc in enumerate(data['accelerometer']):
            if acc > threshold:
                events.append({
                    'timestamp': data['timestamps'][i],
                    'acceleration': acc,
                    'type': 'high_vibration'
                })
      
        return events
  
    def detect_anomalies(self, data):
        """检测异常事件"""
        anomalies = []
      
        # 检测突然加速
        acc_diff = np.diff(data['accelerometer'])
        sudden_changes = np.where(np.abs(acc_diff) > 1.5)[0]
      
        for idx in sudden_changes:
            anomalies.append({
                'timestamp': data['timestamps'][idx],
                'type': 'sudden_acceleration',
                'value': acc_diff[idx]
            })
      
        return anomalies
  
    def calculate_quality_score(self, data):
        """计算传输质量评分（0-100）"""
        score = 100
      
        # 扣分项
        score -= len(self.detect_vibration_events(data)) * 5  # 每次高振动扣5分
        score -= len(self.detect_anomalies(data)) * 3  # 每次异常扣3分
      
        # 温度变化过大扣分
        temp_range = max(data['temperature']) - min(data['temperature'])
        if temp_range > 5:
            score -= (temp_range - 5) * 2
      
        return max(0, min(100, score))
```

---

## 五、时序总结表

| 阶段 | E84 信号 | 你的动作 | 网线状态 | 原因 |
|------|---------|---------|---------|------|
| **Unload 开始** | U_REQ=1 | - | ✅ 连接 | 准备卸载 |
| **AMHS 到位** | VALID=1 | **发送 START** | ✅ 连接 | 最后的通信机会 |
| **开始抓取** | BUSY=1 | - | ⚠️ 断开中 | 网线被拉扯 |
| **抓取完成** | COMPT=1 | - | ❌ 断开 | FOUP 在天上 |
| **在天上** | - | - | ❌ 断开 | FOUP 自主采集 |
| **Load 开始** | L_REQ=1 | - | ❌ 断开 | 请求装载 |
| **FOUP 到达** | CS_0=1 | - | ⚠️ 连接中 | 网线接触 |
| **放置完成** | COMPT=1 | **发送 STOP** | ✅ 连接 | 网线稳定 |
| **读取数据** | 信号复位后 | 读取数据 | ✅ 连接 | 传输数据 |

---

## 六、关键注意事项

### ⚠️ **1. 网线连接稳定性**

```python
def send_stop_command_to_foup(self):
    # 等待网线连接稳定
    time.sleep(0.5)  # 500ms 缓冲时间
  
    # 检查连接状态
    if not self.check_network_connection():
        self.log("Network not ready, retrying...")
        time.sleep(0.5)
  
    # 发送命令
    self.send_command_with_retry(command, max_retries=5)
```

### ⚠️ **2. START 命令失败处理**

```python
def send_start_command_to_foup(self):
    try:
        success = self.send_command_with_retry(command, max_retries=3)
      
        if not success:
            # 选项1：中止传输
            self.abort_transfer()
            raise Exception("Cannot start data collection")
          
            # 选项2：继续传输但记录警告（推荐）
            self.log("WARNING: START command failed, continuing without data collection")
            self.data_collection_started = False
          
    except Exception as e:
        self.handle_start_failure(e)
```

### ⚠️ **3. STOP 命令失败处理**

```python
def send_stop_command_to_foup(self):
    success = self.send_command_with_retry(command, max_retries=5)
  
    if not success:
        # STOP 失败不影响传输，但要记录
        self.log("WARNING: STOP command failed")
      
        # 尝试直接读取数据（FOUP 可能自动停止了）
        self.log("Attempting to retrieve data anyway...")
```

### ⚠️ **4. 数据完整性校验**

```python
def retrieve_foup_data(self):
    data = self.receive_large_data(timeout=30)
  
    if data:
        # 校验数据完整性
        if self.verify_data_integrity(data):
            self.log("✓ Data integrity verified")
            return data
        else:
            self.log("✗ Data corrupted, requesting retransmission")
            return self.retry_data_retrieval()
  
    return None

def verify_data_integrity(self, data):
    """校验数据完整性"""
    # 检查会话ID
    if data.get('session_id') != self.foup_session_id:
        return False
  
    # 检查 CRC 校验和
    if not self.verify_crc(data):
        return False
  
    # 检查数据量是否合理
    if data.get('sample_count') < 100:  # 太少
        return False
  
    return True
```

---

## 七、完整使用示例

```python
# 初始化
loadport = LoadPortWithFOUPDataCollection()

# ═══════════════════════════════════════════════════════
# 场景：FOUP 要去其他设备加工
# ═══════════════════════════════════════════════════════

# 1. 卸载 FOUP 并启动数据采集
if loadport.unload_carrier_with_data_start():
    print("✓ FOUP 已被抓走，开始在天上采集数据")
else:
    print("✗ 卸载失败")

# ... FOUP 在天上飞行，去其他设备加工 ...
# ... 加工完成后，天车将 FOUP 送回 ...

# 2. 装载 FOUP 并停止数据采集
if loadport.load_carrier_with_data_stop():
    print("✓ FOUP 已返回，数据采集完成并已保存")
else:
    print("✗ 装载失败")

# 3. 查询数据分析结果
analysis = loadport.db.get_latest_analysis()
print(f"传输质量评分: {analysis['quality_score']}/100")
print(f"振动事件: {len(analysis['vibration_events'])} 次")
print(f"异常事件: {len(analysis['anomalies'])} 次")
```

---

## 八、最终答案

### ✅ **发送 START 命令的最佳时机：**
**Unload 时，VALID=1 之后，TR_REQ=1 之前**

```python
# 在 unload 流程中
if self.wait_for_signal('VALID', HIGH, timeout=30):
    self.send_start_command_to_foup()  # ← 这里
```

### ✅ **发送 STOP 命令的最佳时机：**
**Load 时，COMPT=1 之后，等待 0.5 秒网线稳定**

```python
# 在 load 流程中
if self.wait_for_signal('COMPT', HIGH, timeout=5):
    time.sleep(0.5)  # 等待网线稳定
    self.send_stop_command_to_foup()  # ← 这里
```

这样设计可以确保：
1. ✅ START 命令在网线断开前成功发送
2. ✅ STOP 命令在网线重连且稳定后发送
3. ✅ 不干扰 E84 握手流程
4. ✅ 数据采集覆盖完整的传输周期
